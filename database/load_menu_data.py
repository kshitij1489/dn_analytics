"""
Load Menu Data into Database

This script populates the menu tables from cleaned_menu.csv:
1. menu_items - Base products
2. variants - Size/quantity options
3. menu_item_variants - Links items to variants with pricing

Usage:
    python3 load_menu_data.py [--db-url DATABASE_URL] [--dry-run]
"""

import csv
import sys
import argparse
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict

# Database connection will be handled by user's preferred method
# This script provides the logic, user can adapt to their DB library

def load_cleaned_menu(filepath: str = None) -> List[Dict]:
    """Load cleaned menu CSV file"""
    menu_data = []
    filepath = filepath or "/app/cleaned_menu.csv"
    with open(filepath, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            menu_data.append({
                'name': row['name'].strip(),
                'type': row['type'].strip(),
                'variant': row['variant'].strip()
            })
    return menu_data


def extract_unique_menu_items(menu_data: List[Dict]) -> List[Dict]:
    """
    Extract unique menu items (name + type combinations)
    Returns list of unique menu items
    """
    seen = set()
    unique_items = []
    
    for item in menu_data:
        key = (item['name'], item['type'])
        if key not in seen:
            seen.add(key)
            unique_items.append({
                'name': item['name'],
                'type': item['type']
            })
    
    return unique_items


def extract_unique_variants(menu_data: List[Dict]) -> List[str]:
    """Extract unique variant names"""
    variants = set()
    for item in menu_data:
        variants.add(item['variant'])
    return sorted(list(variants))


def build_menu_item_variants(menu_data: List[Dict], 
                             menu_item_map: Dict[Tuple[str, str], int],
                             variant_map: Dict[str, int]) -> List[Dict]:
    """
    Build menu_item_variants junction table data
    
    Args:
        menu_data: List of menu items from CSV
        menu_item_map: Dict mapping (name, type) -> menu_item_id
        variant_map: Dict mapping variant_name -> variant_id
    
    Returns:
        List of menu_item_variants records
    """
    # Group by (name, type, variant) to get unique combinations
    seen = set()
    menu_item_variants = []
    
    for item in menu_data:
        key = (item['name'], item['type'], item['variant'])
        if key not in seen:
            seen.add(key)
            menu_item_id = menu_item_map.get((item['name'], item['type']))
            variant_id = variant_map.get(item['variant'])
            
            if menu_item_id and variant_id:
                menu_item_variants.append({
                    'menu_item_id': menu_item_id,
                    'variant_id': variant_id,
                    # Note: Price not in CSV, will need to be set separately or left NULL
                    'price': None  # TODO: Add price data if available
                })
    
    return menu_item_variants


def determine_addon_eligibility(name: str, type: str, variant: str) -> bool:
    """
    Determine if a menu item variant can be used as an addon
    
    Rules:
    - Extras (Cup, Waffle Cone, etc.) are addon eligible
    - Items with variant 1_PIECE that are Extras are addon eligible
    """
    if type == 'Extra':
        return True
    
    # Add specific items that can be addons
    addon_eligible_items = [
        'Cup',
        'Takeaway Cup',
        'Waffle Cone',
        'Butter Waffle Cone',
        'Butter Waffle Cones',
    ]
    
    for item in addon_eligible_items:
        if item in name:
            return True
    
    return False


def determine_delivery_eligibility(name: str, type: str, variant: str) -> bool:
    """
    Determine if a menu item variant is available for delivery
    
    Default: True (most items are delivery eligible)
    Set to False for dine-in only items (e.g., Factory Visit)
    """
    if type == 'Service':
        return False  # Services are typically not deliverable
    
    # Add specific items that are not delivery eligible
    non_delivery_items = [
        'Factory Visit',
        'School Kids',
    ]
    
    for item in non_delivery_items:
        if item in name:
            return False
    
    return True


def generate_sql_statements(menu_data: List[Dict], 
                            output_file: Optional[str] = None) -> Tuple[List[str], List[str], List[str]]:
    """
    Generate SQL INSERT statements for menu tables
    
    Returns:
        Tuple of (menu_items_sql, variants_sql, menu_item_variants_sql)
    """
    # Extract unique data
    unique_items = extract_unique_menu_items(menu_data)
    unique_variants = extract_unique_variants(menu_data)
    
    # Generate menu_items SQL
    menu_items_sql = []
    menu_item_map = {}  # (name, type) -> menu_item_id (will be generated by DB)
    
    for idx, item in enumerate(unique_items, start=1):
        menu_item_map[(item['name'], item['type'])] = idx
        sql = f"""INSERT INTO menu_items (name, type, is_active) 
VALUES ('{item["name"].replace("'", "''")}', '{item["type"]}', TRUE);"""
        menu_items_sql.append(sql)
    
    # Generate variants SQL
    variants_sql = []
    variant_map = {}  # variant_name -> variant_id (will be generated by DB)
    
    for idx, variant in enumerate(unique_variants, start=1):
        variant_map[variant] = idx
        sql = f"""INSERT INTO variants (variant_name) 
VALUES ('{variant}');"""
        variants_sql.append(sql)
    
    # Generate menu_item_variants SQL
    menu_item_variants_sql = []
    seen = set()
    
    for item in menu_data:
        key = (item['name'], item['type'], item['variant'])
        if key not in seen:
            seen.add(key)
            menu_item_id = menu_item_map.get((item['name'], item['type']))
            variant_id = variant_map.get(item['variant'])
            
            if menu_item_id and variant_id:
                addon_eligible = determine_addon_eligibility(item['name'], item['type'], item['variant'])
                delivery_eligible = determine_delivery_eligibility(item['name'], item['type'], item['variant'])
                
                sql = f"""INSERT INTO menu_item_variants 
    (menu_item_id, variant_id, price, is_active, addon_eligible, delivery_eligible) 
VALUES ({menu_item_id}, {variant_id}, NULL, TRUE, {str(addon_eligible).upper()}, {str(delivery_eligible).upper()});"""
                menu_item_variants_sql.append(sql)
    
    return menu_items_sql, variants_sql, menu_item_variants_sql


def generate_python_dicts(menu_data: List[Dict]) -> Tuple[List[Dict], List[Dict], List[Dict]]:
    """
    Generate Python dictionaries for programmatic insertion
    
    Returns:
        Tuple of (menu_items_data, variants_data, menu_item_variants_data)
    """
    # Extract unique data
    unique_items = extract_unique_menu_items(menu_data)
    unique_variants = extract_unique_variants(menu_data)
    
    # Build menu_items data
    menu_items_data = []
    menu_item_map = {}  # (name, type) -> index (for reference)
    
    for idx, item in enumerate(unique_items):
        menu_item_map[(item['name'], item['type'])] = idx
        menu_items_data.append({
            'name': item['name'],
            'type': item['type'],
            'is_active': True
        })
    
    # Build variants data
    variants_data = []
    variant_map = {}  # variant_name -> index (for reference)
    
    for idx, variant in enumerate(unique_variants):
        variant_map[variant] = idx
        variants_data.append({
            'variant_name': variant
        })
    
    # Build menu_item_variants data
    menu_item_variants_data = []
    seen = set()
    
    for item in menu_data:
        key = (item['name'], item['type'], item['variant'])
        if key not in seen:
            seen.add(key)
            menu_item_idx = menu_item_map.get((item['name'], item['type']))
            variant_idx = variant_map.get(item['variant'])
            
            if menu_item_idx is not None and variant_idx is not None:
                addon_eligible = determine_addon_eligibility(item['name'], item['type'], item['variant'])
                delivery_eligible = determine_delivery_eligibility(item['name'], item['type'], item['variant'])
                
                menu_item_variants_data.append({
                    'menu_item_id': menu_item_idx + 1,  # +1 because DB IDs start at 1
                    'variant_id': variant_idx + 1,
                    'price': None,  # TODO: Add price if available
                    'is_active': True,
                    'addon_eligible': addon_eligible,
                    'delivery_eligible': delivery_eligible
                })
    
    return menu_items_data, variants_data, menu_item_variants_data


def main():
    parser = argparse.ArgumentParser(description='Load menu data into database')
    parser.add_argument('--csv', default='cleaned_menu.csv', help='Path to cleaned_menu.csv')
    parser.add_argument('--output-sql', help='Output SQL file path')
    parser.add_argument('--dry-run', action='store_true', help='Generate SQL without executing')
    args = parser.parse_args()
    
    print("=" * 80)
    print("Loading Menu Data from CSV")
    print("=" * 80)
    
    # Load CSV
    print(f"\n1. Loading {args.csv}...")
    menu_data = load_cleaned_menu(args.csv)
    print(f"   Loaded {len(menu_data)} menu entries")
    
    # Extract unique data
    unique_items = extract_unique_menu_items(menu_data)
    unique_variants = extract_unique_variants(menu_data)
    
    print(f"\n2. Extracted unique data:")
    print(f"   - {len(unique_items)} unique menu items")
    print(f"   - {len(unique_variants)} unique variants")
    
    # Generate SQL
    print(f"\n3. Generating SQL statements...")
    menu_items_sql, variants_sql, menu_item_variants_sql = generate_sql_statements(menu_data)
    
    print(f"   - {len(menu_items_sql)} menu_items INSERT statements")
    print(f"   - {len(variants_sql)} variants INSERT statements")
    print(f"   - {len(menu_item_variants_sql)} menu_item_variants INSERT statements")
    
    # Output SQL file
    if args.output_sql:
        print(f"\n4. Writing SQL to {args.output_sql}...")
        with open(args.output_sql, 'w', encoding='utf-8') as f:
            f.write("-- Menu Items\n")
            f.write("-- ============================================================================\n\n")
            for sql in menu_items_sql:
                f.write(sql + "\n")
            
            f.write("\n-- Variants\n")
            f.write("-- ============================================================================\n\n")
            for sql in variants_sql:
                f.write(sql + "\n")
            
            f.write("\n-- Menu Item Variants\n")
            f.write("-- ============================================================================\n\n")
            for sql in menu_item_variants_sql:
                f.write(sql + "\n")
        
        print(f"   SQL file written successfully!")
    
    # Generate Python dicts for programmatic insertion
    print(f"\n5. Generating Python data structures...")
    menu_items_data, variants_data, menu_item_variants_data = generate_python_dicts(menu_data)
    
    print(f"   - {len(menu_items_data)} menu_items records")
    print(f"   - {len(variants_data)} variants records")
    print(f"   - {len(menu_item_variants_data)} menu_item_variants records")
    
    # Summary
    print("\n" + "=" * 80)
    print("SUMMARY")
    print("=" * 80)
    print(f"Total menu entries in CSV: {len(menu_data)}")
    print(f"Unique menu items: {len(unique_items)}")
    print(f"Unique variants: {len(unique_variants)}")
    print(f"Menu item-variant combinations: {len(menu_item_variants_data)}")
    
    # Show sample data
    print("\nSample Menu Items:")
    for item in unique_items[:5]:
        print(f"  - {item['name']} ({item['type']})")
    
    print("\nSample Variants:")
    for variant in unique_variants[:5]:
        print(f"  - {variant}")
    
    if args.dry_run:
        print("\n✅ Dry run complete. No database changes made.")
    else:
        print("\n⚠️  Note: This script only generates SQL/data structures.")
        print("   To actually insert into database, use your preferred DB library:")
        print("   - psycopg2 (PostgreSQL)")
        print("   - sqlite3 (SQLite)")
        print("   - SQLAlchemy (any database)")
        print("\n   Or execute the generated SQL file directly.")


if __name__ == "__main__":
    main()

